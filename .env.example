# Environment Configuration Template for Production Best Practices
# Copy this file to .env and customize for your environment
# Or use specific environment files: .env.development, .env.staging, .env.production

# ============================================================================
# ENVIRONMENT CONFIGURATION
# ============================================================================
# Environment type (development/staging/production)
ENVIRONMENT=development

# Debug mode (true for development, false for production)
DEBUG=true

# ============================================================================
# DATABASE CONFIGURATION
# ============================================================================
# SQLite database file path
DATABASE_URL=student_grades.db

# Database query timeout in seconds
QUERY_TIMEOUT=30

# ============================================================================
# PERFORMANCE OPTIMIZATION
# ============================================================================
# LRU Cache size (number of items)
CACHE_SIZE=1000

# Batch processing size for bulk operations
BATCH_SIZE=100

# ============================================================================
# MONITORING AND ALERTING
# ============================================================================
# Response time alert threshold (milliseconds)
ALERT_RESPONSE_TIME_MS=300

# Cache hit rate alert threshold (0.0 to 1.0)
ALERT_CACHE_HIT_RATE=0.70

# Memory usage alert threshold (MB)
ALERT_MEMORY_MB=500

# Logging level (DEBUG/INFO/WARNING/ERROR/CRITICAL)
LOG_LEVEL=INFO

# ============================================================================
# COST TRACKING
# ============================================================================
# Cost per database query (simulated cloud costs)
COST_PER_DB_QUERY=0.0001

# Cost per 100 API requests (simulated cloud costs)
COST_PER_100_API_CALLS=0.001

# ============================================================================
# SERVER CONFIGURATION
# ============================================================================
# Server host
HOST=0.0.0.0

# Server port
PORT=8080

# ============================================================================
# TESTING CONFIGURATION
# ============================================================================
# Enable quick test mode for faster execution
QUICK_TEST_MODE=false

# Maximum API calls per test (to avoid rate limits)
MAX_API_CALLS_PER_TEST=2

# API call timeout in seconds
API_TIMEOUT=10

# ============================================================================
# ENVIRONMENT-SPECIFIC EXAMPLES
# ============================================================================

# DEVELOPMENT ENVIRONMENT (.env.development)
# ENVIRONMENT=development
# DEBUG=true
# CACHE_SIZE=500
# BATCH_SIZE=50
# ALERT_RESPONSE_TIME_MS=500
# ALERT_CACHE_HIT_RATE=0.60
# ALERT_MEMORY_MB=300
# COST_PER_DB_QUERY=0.0001
# COST_PER_100_API_CALLS=0.001
# LOG_LEVEL=DEBUG

# STAGING ENVIRONMENT (.env.staging)
# ENVIRONMENT=staging
# DEBUG=false
# CACHE_SIZE=1500
# BATCH_SIZE=150
# ALERT_RESPONSE_TIME_MS=250
# ALERT_CACHE_HIT_RATE=0.75
# ALERT_MEMORY_MB=750
# COST_PER_DB_QUERY=0.00015
# COST_PER_100_API_CALLS=0.0015
# LOG_LEVEL=INFO

# PRODUCTION ENVIRONMENT (.env.production)
# ENVIRONMENT=production
# DEBUG=false
# CACHE_SIZE=2000
# BATCH_SIZE=200
# ALERT_RESPONSE_TIME_MS=200
# ALERT_CACHE_HIT_RATE=0.80
# ALERT_MEMORY_MB=1000
# COST_PER_DB_QUERY=0.0002
# COST_PER_100_API_CALLS=0.002
# LOG_LEVEL=INFO

# ============================================================================
# SETUP INSTRUCTIONS
# ============================================================================
# 1. Choose your environment approach:
#    Option A: Single .env file
#      cp .env.example .env
#      # Edit .env with your settings
#
#    Option B: Environment-specific files
#      cp .env.example .env.development
#      cp .env.example .env.staging  
#      cp .env.example .env.production
#      # Edit each file with environment-specific settings
#      # Then: cp .env.development .env (or desired environment)

# 2. Customize the configuration values above for your needs

# 3. Start the application:
#    python main.py

# 4. Access the monitoring dashboard:
#    http://localhost:8080/dashboard

# 5. Run tests:
#    python testsss.py                    # Component tests (fast)
#    python unit_test.py                  # Live API tests (requires server)

# ============================================================================
# PRODUCTION DEPLOYMENT
# ============================================================================
# For production deployment, consider:
# - Set DEBUG=false
# - Use larger CACHE_SIZE (2000+)
# - Set stricter alert thresholds
# - Use INFO or WARNING log level
# - Configure proper database backup
# - Set up external monitoring
# - Use process manager (gunicorn, supervisor)
# - Configure reverse proxy (nginx)
# - Set up SSL/TLS certificates
# - Configure firewall rules

# Example production startup:
# gunicorn main:app -w 4 -k uvicorn.workers.UvicornWorker --bind 0.0.0.0:8080

# ============================================================================
# MONITORING AND OBSERVABILITY
# ============================================================================
# The application provides several monitoring endpoints:
# - /health          - Health check endpoint
# - /metrics         - JSON metrics endpoint  
# - /dashboard       - HTML monitoring dashboard
# - /costs/current   - Current session costs
# - /costs/hourly-summary - Generate cost reports

# Alert files generated:
# - alert.log        - Alert notifications
# - costs.csv        - Hourly cost summaries

# ============================================================================
# TROUBLESHOOTING
# ============================================================================
# Common issues and solutions:

# Database locked errors:
# - Increase QUERY_TIMEOUT
# - Check for long-running queries
# - Ensure proper connection cleanup

# High memory usage alerts:
# - Reduce CACHE_SIZE
# - Check for memory leaks
# - Monitor batch processing size

# Low cache hit rate:
# - Increase CACHE_SIZE
# - Review caching strategy
# - Check data access patterns

# High response times:
# - Optimize database queries
# - Increase cache size
# - Review batch processing
# - Check system resources

# Cost tracking issues:
# - Verify cost parameters are set
# - Check CSV file permissions
# - Monitor disk space for logs